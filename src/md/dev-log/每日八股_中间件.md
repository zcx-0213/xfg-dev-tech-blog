1. ## RabbitMQ如何保证消息不丢失；

   - 我们当时的mysql和redis的双写一致性，就是使用Rabbitmq来实现的；这里面主要考虑了消息的高可用性，保证消息不丢失；要从以下三个方面进行考虑
   - 第一个就是开启生产者确认机制；确保生产者的消息能够进入消息队列；如果发送失败，则记录日志，再去修复数据
   - 开启持久化功能；确保消息未消费前，在队列中不会消失；交换机和队列和消息都要做持久化功能操作
   - 第三个就是开启消费者确认机制为auto;由spring确认消息处理后发出ACK；还要设置重试的次数，我当时重试次数设置的是3次，如果重复三次没有得到回应，就将失败的消息投递到失败交换机中

2. ## RabbitMQ的消息的重复消费问题是怎么解决的？

   - 这个问题在我做的项目中是遇到过的，也是我的项目亮点之一；
   - 我们的消费者设置了自动确认机制，当服务还没来得及发动确认消息时候，服务宕机了，然后服务重启，就会再次消费mq
   - 解决方案：我们的抽奖订单，他有一个业务的唯一标识，我们在处理这个业务的时候，我们会向数据库中查询这个订单的状态，看他是否被消费；如果订单状态被消费过了，就不用消费了
   - 其他的解决方案：这是一个典型的幂等问题。我们可以使用redis分布式锁，还有数据库的锁都是可以解决的；

3. ## Rabbitmq中的死信交换机（也就是延迟队列）了解过么？

   - 我们当时的抽奖项目中，高并发的抽奖过程就用到了延迟队列
   - 延迟队列就是用到了**死信交换机和TTL（消息存活时间）**，实现了消息的延迟投递
   - 首先定义一个普通的交换机和队列
   - 其次设置队列的消息存活时间
   - 声明一个死信交换机和队列，消息过期后，会被加入到死信交换机中，再由死信交换机路由到指定的队列即可；

4. ## 如果有100万条消息堆积在队列，应该怎么处理。

   - 在实际的开发中没遇到过这种情况
   - 首先可以提高消费者的消费能力
   - 再者，增加更多的消费者
   - 还有，扩大队列容积；可以使用RabbitMq的惰性队列；好处：接收到消息直接存储到磁盘，而不是队列；消费者要消费消息才会从磁盘中取出消息；还可以支持数百万条的消息存储；


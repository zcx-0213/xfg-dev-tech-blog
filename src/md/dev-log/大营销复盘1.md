大营销平台系统：

介绍：大营销平台系统是各个互联网公司用来拉新、促销活动、留存的一些重要手段。

# 2024年7月18日复盘

## [营销服务 第1节：抽奖策略领域和库表设计](https://t.zsxq.com/15rGKOAfA)

1. 设计库表

## [营销服务 第2节：基础层持久化数据](https://t.zsxq.com/15Jz9It6s)

1. 本节需求就是让工程对接到数据库
2. 运行ORM（对象关系映射）框架：解决面向对象与关系数据库存在互补匹配的问题；是链接数据库的桥梁，提供了持久化类与数据库之间的映射关系，我们主要使用ORM框架的mybatis框架
3. 持久化对象和mapper的编写
4. app层要引入基础层的pom
5. 在application-dev中配置环境的参数，比如MySQL的版本，当然还有线程池的配置参数等等

## 营销服务 第3节：策略概率装配处理（每个奖品有不同的概率）

1. 大致流程：查询数据库-->策略值计算-->Redis Map数据存储

2. 抽奖算法就是利用了一个空间换时间的一个算法，利用1/概率值，映射到一个数组，抽奖的时候根据范围生成随机值，在空间中定位即可，时间复杂度是O(1);一般都是存入一个比较大的本地内存；可以让多个分布式机器保持数据同步。

3. 本节新增，redis配置，库表操作、

4. 功能逻辑实现:在domain层

   - service中，装配中，定义一个装配抽奖（assembleLotteryStrategy）的接口。接着定义一个StrategyArmory类实现这个接口；（*策略装配库*）
   - assembleLotteryStrategy：就是把每种概率的奖品放在list表中，然后再把各个表放入map，把随机值作为索引，直接获取对应奖品结果。
   - getRandomAwardId对于这个接口，实现它是用来实现抽奖的 *分布式应用，所以需要从 Redis 中获取。抽奖的map表*，然后根据随机值进行抽奖即可，且要存入redis中
   - 在model中，我们会定义用到的实体对象
   - 然后就是你在repository层中定义了一个策略服务仓储接口，IStrategyRepository：（(这样的好处:使domain层中的对象专注于业务逻辑的实现，而不是数据访问的细节）

   <img src="https://images.zsxq.com/FoJxcbReUmCYOUYwJNnuDYPcjFuI?imageMogr2/auto-orient/quality/100!/ignore-error/1&e=1725119999&s=vjjjtmvmjjmtjjy&token=kIxbL07-8jAj8w1n4s9zv64FuZZNEATmlU_Vm6zD:c6DNI670KDDrQUePEE0T0o-KUcM=" alt="img" style="zoom:50%;" />

   ## 营销服务 第4节：策略权重概率装配

   1. 这一章节是根据你消耗的积分得到你能够抽奖的奖品的范围，也就是说控制你能抽到的奖品的好坏
   1. 首先根据校验信息
   1. 根据策略id 查 策略实体（主要是查rulemodel--》rule_blacklist,rule_weight）
   1. 然后根据策略id 和 rulemodel  查询具体的权重规则（）——6000:102,103,104,105,106,107,108,109
   1. 权重的策略装配就是根据不同的积分值，去给不同的奖品分配概率；
   1. 最后用户通过 策略id+权重值来进行抽奖<img src="https://article-images.zsxq.com/FjnUs31XtazuiWSDMxdhKNtfTAyZ" alt="img" style="zoom: 33%;" />

   ## 营销服务 第5节：抽奖前置规则过滤（过滤黑名单-羊毛党）抽奖规则（权重、黑名单）

   1. 如果是黑名单用户，就会返回指定的奖品id
   2. 权重规则是和黑名单规则同一级别的；所以说对于整个抽奖过程，我分为了抽奖前，抽奖中，抽奖后
   3. rule包里面是抽奖规则；用来实现整个规则的处理
   4. raffe包是抽奖功能的实现；利用模版模式来定义整个抽奖流程；
   5. 我们会定义一个规则接口，传入抽奖规则的实体：（RuleActionEntity<T> filter(RuleMatterEntity ruleMatterEntity);）
   6. **一般都是判断抽奖用户的id是否在黑名单用户的范围内；100:user001,user002,user003；一般都会配置一个人群id的；人群是通过量化工程师通过数据标签计算得到的；**
   7. ![img](https://images.zsxq.com/Fp-9WPV_3Hbc57c7yH4oOaVzym6n?imageMogr2/auto-orient/quality/100!/ignore-error/1&e=1725119999&s=vjjjtmvmjjmtjjy&token=kIxbL07-8jAj8w1n4s9zv64FuZZNEATmlU_Vm6zD:ZjaJswBlkXNGeiUUwYMRGbIkYxo=)
   8. ![image-20240724152443704](C:\Users\王冉\AppData\Roaming\Typora\typora-user-images\image-20240724152443704.png)

5. # 第6节：抽奖中置规则过滤（激励用户抽奖消耗积分---代码设计为松耦合，把他分为不同阶段）

   - ![image-20240724160052212](C:\Users\王冉\AppData\Roaming\Typora\typora-user-images\image-20240724160052212.png)

6. # 第7节：责任链模式处理抽奖规则

   1. 责任链模式是对上述规则的一个优化：因为黑名单规则和权重规则和白名单规则都是互斥的，执行这一个就不执行另外一个了；
   2. 责任链

7. 规则树

   [5.4抽奖规则树模型结构设计小解 (zsxq.com)](https://articles.zsxq.com/id_ztx45s829ars.html)

8. ![img](https://images.zsxq.com/Fk5NnXDMHinO7p96VwtxGY3_BJ9f?imageMogr2/auto-orient/quality/100!/ignore-error/1&e=1725119999&s=vjjjtmvmjjmtjjy&token=kIxbL07-8jAj8w1n4s9zv64FuZZNEATmlU_Vm6zD:i199p1qZzsuOFVHfkE5RzTFgYP8=)

9. # 第9节：模板模式串联抽奖规则

   1. 在 AbstractRaffleStrategy 抽象类，串联调用流程，显示责任链，再是规则树；责任链处理的是不同的抽奖【黑名单抽奖、权重抽奖、默认抽奖】
   2. 规则树处理的是抽到的奖品是否正常发放给用户（ps看用户的积分）；如果是默认抽奖，就要判断它的次数，还有库存等进行校验

   3. **参数校验、责任链抽奖计算、规则树抽奖过滤、返回抽奖结果。**

   4. ![image-20240725170931485](C:\Users\王冉\AppData\Roaming\Typora\typora-user-images\image-20240725170931485.png)

10. ## 不超卖库存规则实现

   1. **普通的**就是给数据库的库存字段加一个锁，但是效率太低了，大量用户获得数据库链接，需要等待前一个用户更新好库存表之后释放锁才能使用
   2. 因为等待的时间长了，数据库资源是很宝贵的；你占用了，其他请求进不来，导致响应时间很慢【【前台的用户越着急，越疯狂点击，直至越来越卡到崩溃】】
   3. 对于这样的秒杀场景呢，我们使用redis来辅助；他只要不超卖就OK；但是不要使用一个key加锁在释放的做法；这样子效率也很低，我们尽可能去**考虑分摊竞争；**达到**无锁化**；才是分布式架构的核心；
   4. 我们得到一个抽奖记录，得到一个奖品的id，我们必须做一个库存扣减工作；才能算成功，不然就要走兜底产品
   5. 基于上一节的结点，我们加一个decr的操作，我们使用decr方式扣减库存；decr是一个原子操作，效率很高
   6. **setnx**是一种兜底手段，防止超卖，避免后序库存的恢复，导致重复消费；这个是应对库存恢复呢；
   7. 当我们库存消耗完了，我们使用Redission实现延迟队列+定时任务；缓慢消耗队列的数据；更新数据库表的变化
   8. 存入缓存的奖品信息是在装配抽奖哪里进行装配操作的。
   9. 新增的 **IRaffleStock 接口**；是处理扣减库存结束后，写到到 redis 延迟队列；我么你定义一个定时任务来扫描延迟队列，然后更新数据库
   10. **细节：**装配库存和扣减库存用一个实现类进行实现；做一些功能的内聚
   11. 

   

   

   ## 营销服务 第11节：抽奖API接口实现

   1. 服务端应该提供接口标准，设计服务端的接口
   2. 一般都是对的PRD文档进行设计接口，前端现根据文档mock接口，后端开发在联调
   3. 在我们这里有一个trigger模块；

   # 营销服务 第12节：用户参与抽奖活动库表设计

   - 给抽奖功能包装一个外壳：包装成一个抽奖活动，这个活动有活动时间、总预算、个人可参与次数等
   - 一个抽奖活动的配置：相关的库存、时间、状态、个人在总、月、日还可以参与抽奖的次数
   - 我们可以把用户参与抽奖理解为商城的一次下单，下单后才具备参与抽奖的资格；规则校验后，我们需要创建一个聚合对象：1、活动订单2、次数记录3、次数的账户
   - 通过聚合对象入库------然后进行抽奖
   - 这一节做了一个类似于幂等的操作，比如说淘宝下单，我们未支付
   - 这个就是我们创建一个活动订单，他有一个状态的字段，如果这个订单未消费，就会接着这个订单执行订单操作
   
   
   
   # 第13节：引入分库分表路由组件
   
   1. 描述：把用户的行为数据，使用路由组件将数据散列到分库分表中
   2. 我的项目中有有一个配置库（big_market）和两个分库（big_market_01、big_market_02）
   3. 我们对两个分库做进行配置路由操作---分库分表   配置库就是一个单库单表存储活动等配置类信息
   4. 判断过程是基于AOP切面操作---可以使用自定义注册作为一个切入点：这里的自定义注解就是@Dbrouter，做一个AOP切面
      - 对Dao操作做切面 处理，会检测到用户ID进行路由，从切面入参中拿到对应的ID（key），拿到这个值我们进行一个hash计算，然后对7取余
      - 得到一个最终路由的值
      - 计算出的值我们会放在ThreadLocal中，作用，在同一个线程下，我们可以随时随机获得ThreadLocal中的值
      - 解释上面这句话A方法----B方法-----C方法----都在同一个线程下，在每个方法内都可以调用到ThreadLocal中的值（这几个方法中任意方法穿进去我们都可以使用它）；存储的规模量比较小，所以也不那么占用资源
      - 然后就是有一个spring处理动态路由的接口； 我们去实现它，比如在实现类中我们要操作数据库了，我们就可以直接从ThreadLocal中获取到这个分库分表的值
      - 然后就是利用一个mybatis 插件  去修改这个SQL语句---动态修改：![image-20240726190850283](C:\Users\王冉\AppData\Roaming\Typora\typora-user-images\image-20240726190850283.png)
   
   
   
   #  第14节：抽奖活动订单流程设计
   
   描述：活动有一个sku：活动表描述了活动的基本信息
   
   用户表里面也有一个sku  用于链接用户参与活动的次数
   
   
   
   用户下单进行抽奖：
   
   - 通过sku查询活动信息（）得到活动ID 和 该活动的总次数；还有一个是活动个人参与次数ID *个人可参与多少次活动（总、日、月）*
   - 然后根据活动信息，可以查询到活动信息
   - 根据 活动个人参与次数ID 查出该活动的活动（总、日、月）
   - 终于明白了 sku 是一个商品，我们购买这个商品  那个活动个人参与次数 就是给他充值的！
   - 你把活动当成一个商品，把 raffle_activity_sku 当成是这个商品的可售库存。当用户购买后，就是给用户对应的这个活动商品，充值进去相应的 raffle_activity_count 额度。很类似，购买花费充值卡，卡上的额度。
   
   
   
   # 营销服务 第17节：用于领取活动库表设计
   
   
   
   - 账户，在扣减额度和用户的订单，要在一个事务内完成。
   - 存在未消费的活动订单，订单未消费，会存在一个未消费的订单；
   - 为什么要异步发奖
   -  构建聚合对象 --- 就是创建一个事务![image-20240727150005780](C:\Users\王冉\AppData\Roaming\Typora\typora-user-images\image-20240727150005780.png)
   
   
   
   # 营销服务 第19节：写入中奖记录和任务补偿发送MQ
   
   
   
   - 因为一些奖品是接口形的，所以没办法直接发奖，所以通过异步的方式进行发奖
   
   
   
   
   
   
   
   

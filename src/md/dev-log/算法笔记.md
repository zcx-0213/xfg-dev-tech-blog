1. ## 二叉树的层序遍历

   - 需要用到队列（Queue）的思想，先进先出;可以用LinkedList<>来实现
   - Queue<Treenode> queue = new LinkedList<Treenode>();
   - 入队操作，queue.offer(root);
   - 队列长度是queue.size();
   - 根据for循环，遍历每一层
   - 判断是否有左右子树，然后入队
   - 出队操作是 queue.poll();

2. ## 二叉树的前序遍历（根左右）

   - 运用递归的思想
   - 创建一个列表
   - 调用一个方法传入一个list和根
   - 然后方法内list.add(root)
   - 然后递归调用方法传入list和root就行

3. ## 矩阵 矩阵置零（给定一个 m x n的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** ）

   - 首先定义两个两个一维地数组进行标记；
   - 第一个一维数组大小就是横长
   - 然后两个for循环遍历数组。if过某个数组等于0，那么就让他的横坐标和竖坐标都变为true

4. ## 合并区间（

   - ```
      输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
      输出：[[1,6],[8,10],[15,18]]
      ```

   - 首先就是需要对二维数组里面的一位数组进行排序；

   - 然后呢，需要定义一个list存储每个一维的数组，list.get(i)[0]  就代表了【1,3】的1

   - 然后就开始逻辑判断

   - 如果相交且list.size()>0,则进行合并

   - 否则加入到队列计科

   - 有一个小技巧就是 用一个数字记录了 list的大小

   - 最后是list.toarray(new int[list.size()][])

   大功告成
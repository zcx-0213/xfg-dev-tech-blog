1. ## Spring框架

   - 最核心的概念就是容器：某种特定组件运行，提供必要支持的一个软件环境吧；比如Docker这样的软件也是一个容器，提供了必要的linux环境；
   - 容器的功能：
     - 提供一个组件运行的环境；管理所有轻量级的javaBean组件
     - 还提供许多底层的服务；
     - 组件的生命周期管理、配置、组装服务、AOP支持
   - IOC容器：
     - 也叫做控制反转；又称为依赖注入；就是把一些公用的组件：创建+配置与组件的使用相分离，并且由IOC容器负责管理组件的生命周期
     - ioc容器负责实例化所有的组件；需要告诉容器组件之间的依赖关系，如何创建组件，那我们就用一个XML文件来进行配置；
       - ![image-20240724095338769](C:\Users\王冉\AppData\Roaming\Typora\typora-user-images\image-20240724095338769.png)	
       - 上面是3个组件；其中把id为dataSource的组件通过ref的形式（通过属性，就是调用getDatasource()的方法）注入带另外两个组件中
       - 在IOC容器中，我们把所有的组件统称为javabean，配置一个组件就是配置一个bean；
       - 依赖注入方式：上面我们是使用的set的方式进行依赖注入的，我们还可以使用构造方法的方式进行依赖注入
       - ![image-20240724100134944](C:\Users\王冉\AppData\Roaming\Typora\typora-user-images\image-20240724100134944.png)
       - Spring IOC容器支持属性注入和构造方法注入，也可以混合使用的
     - IOC容器是一个**无侵入**的容器；而且高度可扩展；就是一个应用程序的组件无需实现spring的特定接口；无侵入也就是，组件不知道自己在容器中运行；
       - 好处1、组件既可以在ioc容器中运行，也可以自己配置运行
       - 最小化对代码的影响，无需实现接口等；
       - 降低耦合度
     - 每一个bean都有一个唯一id标识
     - 在xml文件是通过property的 ref=id的方式进行注入另外一个bean
     - 且bean的顺序不重要；容器会根据依赖关系自动初始化![image-20240724101557227](C:\Users\王冉\AppData\Roaming\Typora\typora-user-images\image-20240724101557227.png)
     - 如果注入的不是bean 是数据类型，我们就要使用value关键字进行注入，还有一些jdbc链接![image-20240724101806919](C:\Users\王冉\AppData\Roaming\Typora\typora-user-images\image-20240724101806919.png)
     - 我们创建好XML文件之后呢，我们需要配置这个xml文件，我们需要创建一个SPringIOC容器的bean；然后加载配置文件，让spring容器为我们创建并且装配xml文件中的指定的bean；
   - 如果需要一个bean创建多个实例，例如连接多个数据库，我们就需要创建多个Datasource实例：我们就在@configuration类中创建多个同类型的bean
   - ![image-20240725085821272](C:\Users\王冉\AppData\Roaming\Typora\typora-user-images\image-20240725085821272.png)
   - 创建bean的时候要使用不同的名字，注入的时候也要使用不同的名字进行注入
   - 或者用@primary来定义使用注数据源
   - 别名`@Qualifier("beanName")`指定某个Bean；

2. ## spring框架下的单例bean是线程安全的么

   1. 不是线程安全的。当多个用户请求一个服务时候，每个服务都会分配一个线程；这些线程会并发执行一个业务逻辑。那么当业务逻辑中有对单利状态修改的时候，则要考虑线程同步问题。
   2. 如果要解决这个问题，spring框架中没有对单例bean的多线程的封装处理；需要开发者自行搞定
   3. 比如项目中使用的Spring bean都是不可以改变状态的bean，（比如Service类和Dao类）；
   4. 如果bean有多种状态的话，我们可以把单例模式改为，把singleton模式改为prototype模式

3. ## 什么是AOP

   1. 面向切面编程；在Spring中用于一些与业务逻辑无关，却对多个对象产生影响的公共行为，然后抽取公共板块复用，降低耦合。常见的有记录日志功能；还有一些**事务处理功能**

4. ## 你们项目中有没有使用到AOP

   1. 主要记录了系统的操作日志
   2. 这样子实现的，使用的aop的  **环绕通知+切点表达式**；  这个切点表达式 主要是用来找到要记录纸日志方法的所在地方；**通过环绕通知的参数获取该方法的参数；**比如类信息，方法信息、注解等； @Around(execution(权限修饰符 返回值类型 全限定类名.方法名(形参列表)))
   3. Aspect注解声明切面类：（）

5. ## spring中事务是如何实现的？

   - ​	spring中的事务由aop

6. ## spring事务失效的场景（原理就是我们自己处理了异常，没有交给spring的事务给管理）

   1. @transactional  这个注解 就是别事务管理了
   2. **把异常处理掉了  ，1/0处理了，后面的代码就不执行了，导致事务失效了；** 转账场景
   3. 如果不处理 ，发生异常，事务会正常回滚；（意思就是事务通知必须自己捕获了异常。才会事务回滚，被处理了就不会回滚了）
   4. 解决办法就是，我们处理后，抛出一个转账失败的异常就OK（手动添加）
   5. **抛出检查异常**也会导致失效；因为spring默认的是回滚，非检查的异常(runtime异常的)
   6. 解决办法就是在transactional(rollBackFor=Exception.class),只要有异常就回滚
   7. **非public方法会导致事务失效**：spring的事务管理必须是public方法，解决办法就改为public

7. ## spring的生命周期：

   1. 就是spring如何加载bean和管理bean（管理和创建）
   2. 我看过一些原码
   3. bean的流程：**在spring容器在实例化**的时候，首先通过一个非常重要的类，叫做**BeanDefinition**的类，他通过**xml文件**获取了bean的重要信息传入BeanDefinition对象中，比如**bean的类名路径，是否延迟加载，是否为单例**等等信息
   4. **创建bean的时候：**
      1. 通过构造函数，实例化bean对象
      2. 依赖注入：@resource
      3. 实现aware接口，重写里面的方法实现相应的功能：比如说获取bean对象的名字、火速beanFactory
      4. 然后实现前置 后置处理器BeanpostProcessor
      5. 初始化bean对象，就是实现接口InitializingBean
      6. 执行后置处理器器BeanPostProcessor，主要是对bean进行增强，有可能在这里产生代理对象（利用AOP 增强对象 生成代理对象，对其增强）

8. ## Spring中的循环引用

   1. 就是循环依赖，可以依靠spring的三级缓存进行处理管理
   2. 一级缓存 存入完成整个生命周期的对象：(单例池)，已经初始化完成的bean对象
   3. 二级缓存，存储还未执行完整个生命周期的对象：
   4. 三级缓存，缓存的是objectFactory，对象工厂；用来创建某个对象

9. ## 具体的解决流程是怎样的

   1. 实现通过构造方法实例化Bean A对象，然后在初始化方法的时候，需要Bean的B对象
   2. 这时候就要创建B对象，B实例化完成后，会创建ObjectFactory对象存入三级缓存；singletonFactories 
   3. B需要注入进A，所以需要通过三级缓存ObjectFactory来创建一个A对象，存入二级缓存，可能是A的普通用对象，也可能是代理对象，都可以让ObjectFactory来生产对应的对象，这也是三 级缓存的关键
   4. B通过二级缓存获得到A的对象后可以正 常注入，B创建成功，存入一级缓存singletonObjects 
   5. A初始化完毕，因为B对象已经创建完成，则可以直接注入B。A 创建成功存入一次缓存singletonObjects
   6. 二级缓存中对象清理掉

10. springmvc的执行流程

  1. ![image-20240726113318470](C:\Users\王冉\AppData\Roaming\Typora\typora-user-images\image-20240726113318470.png) 

11. ## springboot的自动配置原理

   - springboot的引导类中有一个自动配置的注解@SpringBootApplication
   - 他是对三个注解的封装
     - SpringBootConfiguration：
     - EnableAutoConfiguration：自动化配置的核心注解；
       - 该注解通过**@import注解**导入对应的**配置选择器；**  关键是内部就读取了该项目和该项目引用的jar包的 classpath路径下的 META-INF/spring.factorys 文件中所有配置的类的全类名；
       - 这些配置类的bean会根据条件注解所必须的条件 是否导入到Spring容器中
         - 一般条件判断会有像 @ConditionalOnClass 这样的注解，判断是否有对应的 class文件，如果有则加载该类，把这个配置类的所有的Bean放入spring容器 中使用。
     - ComponentScan

12. ## Spring 的常见注解有哪些？

   1. 声明bean：@Component，@Service @controller @repository
   2. 依赖注入的：@Autowired @Resource @Qualifier
   3. 设置作用域@scope
   4. Spring配置：@Configuration @ComponentScan @Bean
   5. aop: @PointCut @Around @Before @After @Aspect

13. ## SpringMVC常见的注解有哪些？

   1. @RequestMapping  映射请求路径
   2. @RequestBody  用来实现介绍http请求的json数据 将json转换为body对象
   3. @ResponseBody  用来实现将java对象转换为json对象  响应给客户端
   4. @RequestParam  ：指定请求参数的名称
   5. @RequestHeader：获取指定的请求头数据

14. ## Mybatis执行流程：

   1. 首先读取mybatis的配置文件和读取映射文件
   2. 构建mybatis回话工程，一般一个项目中有一个，sqlsessionFactory，单例的，由Spring管理
   3. 工厂创建sqlsession对象进行，这里面含有执行sql语句的所有方法；
   4. 然后就是操作数据库的接口 Executor，同时负责查询缓存的维护
   5. Executor接口的执行方法中有一个**MappedStatement**类型的参数，封装了 映射信息
   6. 输入参数映射
   7. 输出结果映射